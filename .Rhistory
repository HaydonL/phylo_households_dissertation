Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- params[Sigma_names]
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
grid$density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
density_list[[k]] <- grid$density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste0("Cluster ", k, " weight = ",
signif(weights[k]), 3)) +
scale_fill_gradient(low = "white", high = "red")
plots[[k]] <- p
print(k)
}
# Final plot
full_density <- rep(0, length(grid))
for (k in 1:K){
full_density <- full_density + weights[k] * density_list[[k]]
print(k)
}
grid$density <- full_density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste("Final mixture", draw_no)) +
scale_fill_gradient(low = "white", high = "red")
plots[[K + 1]] <- p
final_plot <- ggarrange(plotlist = plots, nrow = 3, ncol = 3)
#ggsave(filename, final_plot, width = 7, height = 7)
print(final_plot)
}
params <- extract_data(draws, 3, 1000)
plot_normal(params, "logit_SG_IW_plots.pdf", K = 6)
x <- seq(-6, 6, by = 0.1)
density_list <- list()
plots <- list()
weight_names <- paste0("weights[", 1:K, "]")
weights <- as.numeric(params[weight_names])
weights
grid <- expand.grid(x, x)
k <- 1
mu_names <-  c(paste0("mus[", k, ",1]"), paste0("mus[", k, ",2]"))
Sigma_ends <- c("1,1]", "1,2]", "2,1]", "2,2]")
Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- params[Sigma_names]
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
mus
Sigma
grid
density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
densirty
density
dmvnorm(c(0,0), mus, sigma = )
dmvnorm(c(0,0), mus, sigma = Sigma)
Sigma
?dmvnorm
dmvnorm(c(0,0))
cov2cor(Sigma)
Sigma
dmvnorm(c(0,0), mus, sigma = Sigma, checkSymmetry = FALSE)
cov2cor
is.numeric(Sigma)
plot_normal <- function(params, filename, K = 5, draw_no = NA){
x <- seq(-6, 6, by = 0.1)
density_list <- list()
plots <- list()
weight_names <- paste0("weights[", 1:K, "]")
weights <- as.numeric(params[weight_names])
for (k in 1:K){
grid <- expand.grid(x, x)
mu_names <-  c(paste0("mus[", k, ",1]"), paste0("mus[", k, ",2]"))
Sigma_ends <- c("1,1]", "1,2]", "2,1]", "2,2]")
Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- as.numeric(params[Sigma_names])
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
grid$density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
density_list[[k]] <- grid$density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste0("Cluster ", k, " weight = ",
signif(weights[k]), 3)) +
scale_fill_gradient(low = "white", high = "red")
plots[[k]] <- p
print(k)
}
# Final plot
full_density <- rep(0, length(grid))
for (k in 1:K){
full_density <- full_density + weights[k] * density_list[[k]]
print(k)
}
grid$density <- full_density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste("Final mixture", draw_no)) +
scale_fill_gradient(low = "white", high = "red")
plots[[K + 1]] <- p
final_plot <- ggarrange(plotlist = plots, nrow = 3, ncol = 3)
#ggsave(filename, final_plot, width = 7, height = 7)
print(final_plot)
}
params <- extract_data(draws, 3, 1000)
plot_normal(params, "logit_SG_IW_plots.pdf", K = 6)
x <- seq(-6, 6, by = 0.1)
density_list <- list()
plots <- list()
weight_names <- paste0("weights[", 1:K, "]")
weights <- as.numeric(params[weight_names])
grid <- expand.grid(x, x)
length(grid)
length(grid$density)
mu_names <-  c(paste0("mus[", k, ",1]"), paste0("mus[", k, ",2]"))
Sigma_ends <- c("1,1]", "1,2]", "2,1]", "2,2]")
Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- as.numeric(params[Sigma_names])
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
grid$density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
length(grid$density)
plot_normal <- function(params, filename, K = 5, draw_no = NA){
x <- seq(-6, 6, by = 0.1)
density_list <- list()
plots <- list()
weight_names <- paste0("weights[", 1:K, "]")
weights <- as.numeric(params[weight_names])
for (k in 1:K){
grid <- expand.grid(x, x)
mu_names <-  c(paste0("mus[", k, ",1]"), paste0("mus[", k, ",2]"))
Sigma_ends <- c("1,1]", "1,2]", "2,1]", "2,2]")
Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- as.numeric(params[Sigma_names])
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
grid$density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
density_list[[k]] <- grid$density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste0("Cluster ", k, " weight = ",
signif(weights[k]), 3)) +
scale_fill_gradient(low = "white", high = "red")
plots[[k]] <- p
}
# Final plot
full_density <- rep(0, length(grid$density))
for (k in 1:K){
full_density <- full_density + weights[k] * density_list[[k]]
}
grid$density <- full_density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste("Final mixture", draw_no)) +
scale_fill_gradient(low = "white", high = "red")
plots[[K + 1]] <- p
final_plot <- ggarrange(plotlist = plots, nrow = 3, ncol = 3)
#ggsave(filename, final_plot, width = 7, height = 7)
print(final_plot)
}
params <- extract_data(draws, 3, 1000)
plot_normal(params, "logit_SG_IW_plots.pdf", K = 6)
grid_theme <- function(){
theme(axis.text = element_blank())
}
plot_normal <- function(params, filename, K = 5, draw_no = NA){
x <- seq(-6, 6, by = 0.1)
density_list <- list()
plots <- list()
weight_names <- paste0("weights[", 1:K, "]")
weights <- as.numeric(params[weight_names])
for (k in 1:K){
grid <- expand.grid(x, x)
mu_names <-  c(paste0("mus[", k, ",1]"), paste0("mus[", k, ",2]"))
Sigma_ends <- c("1,1]", "1,2]", "2,1]", "2,2]")
Sigma_names <- c()
for (i in 1:4){
end <- Sigma_ends[i]
Sigma_names[i] <- paste0("Sigmas[", k, ",", end)
}
mus <- as.numeric(params[mu_names])
Sigmas <- as.numeric(params[Sigma_names])
Sigma <- matrix(Sigmas, nrow = 2, byrow = TRUE)
grid$density <- apply(grid, 1, dmvnorm, mean = mus, sigma = Sigma)
density_list[[k]] <- grid$density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste0("Cluster ", k, " weight = ",
signif(weights[k]), 3)) +
scale_fill_gradient(low = "white", high = "red")
plots[[k]] <- p
}
# Final plot
full_density <- rep(0, length(grid$density))
for (k in 1:K){
full_density <- full_density + weights[k] * density_list[[k]]
}
grid$density <- full_density
p <- ggplot(grid) + geom_tile(aes(x = Var1, y = Var2, fill = density)) +
grid_theme() + labs(title = paste("Final mixture", draw_no)) +
scale_fill_gradient(low = "white", high = "red")
plots[[K + 1]] <- p
final_plot <- ggarrange(plotlist = plots, nrow = 3, ncol = 3)
#ggsave(filename, final_plot, width = 7, height = 7)
print(final_plot)
}
params <- extract_data(draws, 3, 1000)
plot_normal(params, "logit_SG_IW_plots.pdf", K = 6)
a <- c(mean, sum, lm)
a[1]
a[2]
a[3]
?do.call
params <- list(sd = 0.05, offset = 0.3)
a <- list()
a["n"] <- 4
a
paeams
params
a <- list()
a$n <- 1
a
params <- list(n = 100, sd = 0.01, offset = 0.3)
#'
#' @param n - positive integer, number of 2D observations wanted
#' @param sd - positive real, noise around observation
#' @param offset - positive real, between 0 and 1
#'
#' @return a 2 by n matrix containing observations from the required
#' distribution
#' @export
#'
#' @examples
roffset <- function(n, sd, offset){
n_extra <- as.integer(1.5*n) # Initially generate more samples than needed
output_x <- c()
output_y <- c()
# Re-sample until we have enough valid observations
while(length(output_x) < n){
x <- runif(n_extra, 0, 1 - offset)
errors <- rnorm(n_extra, 0, sd)
y <- x + offset + errors
# Filter out observations where y not in (0,1)
in_bounds <- y > 0 & y < 1
x <- x[in_bounds]
y <- y[in_bounds]
# Append valid observations
output_x <- c(output_x, x)
output_y <- c(output_y, y)
}
# Pick out only the first n observations and return
output_x <- output_x[1:n]
output_y <- output_y[1:n]
return(matrix(c(output_x, output_y), ncol=2))
}
do.call(roffset, params)
plot(do.call(roffset, params))
?cbind
?rbind
?rep
data <- as.data.frame(matrix(nrow = 3, ncol = 3))
data
names(data) <- c("a", "b", "c")
data
#' Simulate points from a Poisson Process
#'
#' @param rate - a positive real number, the rate of the Poisson process
#' @param rsample - a function to sample from the density of the Poisson process
#' @param ... - further arguments to rsample
#'
#' @return A data frame containing coordinates for points from a Poisson process
#' @export
#'
#' @examples
simulate_PP <- function(rates, rsamplers, params){
n_groups <- length(rates)
coords_list <- list()
for (group in 1:n_groups){
rate <- rates[group]
rsample <- rsamplers[group]
param_list <- params[[group]]
n_obs <- rpois(1, rate) # Sample total number of observations
param_list$n <- n_obs
coords <- do.call(rsample, param_list) # Sample coordinates of observations
coords <- cbind(coords, rep(group, n_obs))
coords_list[[group]] <- coords
}
# Combine coordinate data
data <- as.data.frame(rbind(coords_list))
names(data) <- c("x", "y", "group")
return(as.data.frame(data))
}
rates <- c(150, 150, 150, 150)
#' Generate distributions centred along the line y = x
#'
#' @param n - positive integer, number of 2D observations wanted
#' @param sd - positive real, noise around observation
#'
#' @return a 2 by n matrix containing observations from the required
#' distribution
#' @export
#'
#' @examples
rline <- function(n, sd){
n_extra <- as.integer(1.5*n) # Initially generate more samples than needed
output_x <- c()
output_y <- c()
# Re-sample until we have enough valid observations
while(length(output_x) < n){
x <- runif(n_extra)
errors <- rnorm(n_extra, 0, sd)
y <- x + errors
# Filter out observations where y not in (0,1)
in_bounds <- y > 0 & y < 1
x <- x[in_bounds]
y <- y[in_bounds]
# Append valid observations
output_x <- c(output_x, x)
output_y <- c(output_y, y)
}
# Pick out only the first n observations and return
output_x <- output_x[1:n]
output_y <- output_y[1:n]
return(matrix(c(output_x, output_y), ncol=2))
}
#' Simulate points uniformly on a 2D grid
#'
#' @param n - positive integer, number of 2D observations wanted
#'
#' @return a 2 by n matrix containing observations from a uniform distribution
#' @export
#'
#' @examples
runif2D <- function(n){
data <- matrix(runif(2*n), ncol = 2)
return(data)
}
samplers <- c(runif2D, rline, rline, roffset)
params <- list()
params[[1]] <- list()
params[[2]] <- list(sd = 0.1)
params[[3]] <- list(sd = 0.03)
params[[4]] <- list(sd = 0.1, offset = 0.3)
data <- simulate_PP(rates, samplers, params)
grouping()
n_groups <- length(rates)
coords_list <- list()
rate <- rates[group]
group <- 1
rate <- rates[group]
rsample <- rsamplers[group]
rsamplers <- c(runif2D, rline, rline, roffset)
rsample <- rsamplers[group]
param_list <- params[[group]]
param_list
n_obs <- rpois(1, rate) # Sample total number of observations
param_list$n <- n_obs
param_list
coords <- do.call(rsample, param_list) # Sample coordinates of observations
rsample
rsample <- rsamplers[[group]]
rsample
coords <- do.call(rsample, param_list) # Sample coordinates of observations
data <- simulate_PP(rates, rsamplers, params)
#' Simulate points from a Poisson Process
#'
#' @param rate - a positive real number, the rate of the Poisson process
#' @param rsample - a function to sample from the density of the Poisson process
#' @param ... - further arguments to rsample
#'
#' @return A data frame containing coordinates for points from a Poisson process
#' @export
#'
#' @examples
simulate_PP <- function(rates, rsamplers, params){
n_groups <- length(rates)
coords_list <- list()
for (group in 1:n_groups){
rate <- rates[group]
rsample <- rsamplers[[group]]
param_list <- params[[group]]
n_obs <- rpois(1, rate) # Sample total number of observations
param_list$n <- n_obs
coords <- do.call(rsample, param_list) # Sample coordinates of observations
coords <- cbind(coords, rep(group, n_obs))
coords_list[[group]] <- coords
}
# Combine coordinate data
data <- as.data.frame(rbind(coords_list))
names(data) <- c("x", "y", "group")
return(as.data.frame(data))
}
data <- simulate_PP(rates, rsamplers, params)
data
str(data)
?rbind
#' Simulate points from a Poisson Process
#'
#' @param rate - a positive real number, the rate of the Poisson process
#' @param rsample - a function to sample from the density of the Poisson process
#' @param ... - further arguments to rsample
#'
#' @return A data frame containing coordinates for points from a Poisson process
#' @export
#'
#' @examples
simulate_PP <- function(rates, rsamplers, params){
n_groups <- length(rates)
coords_vector <- numeric(n_groups)
for (group in 1:n_groups){
rate <- rates[group]
rsample <- rsamplers[[group]]
param_list <- params[[group]]
n_obs <- rpois(1, rate) # Sample total number of observations
param_list$n <- n_obs
coords <- do.call(rsample, param_list) # Sample coordinates of observations
coords <- cbind(coords, rep(group, n_obs))
coords_vector[group] <- coords
}
# Combine coordinate data
data <- as.data.frame(rbind(coords_list))
names(data) <- c("x", "y", "group")
return(as.data.frame(data))
}
data <- simulate_PP(rates, rsamplers, params)
a <- list()
list[[1]] <- matrix(nrow = 3, ncol = 2)
a[[1]] <- matrix(nrow = 3, ncol = 2)
a[[2]] <- matrix(1, nrow = 5, ncol = 2)
do.call(rbind, a)
#' Simulate points from a Poisson Process
#'
#' @param rate - a positive real number, the rate of the Poisson process
#' @param rsample - a function to sample from the density of the Poisson process
#' @param ... - further arguments to rsample
#'
#' @return A data frame containing coordinates for points from a Poisson process
#' @export
#'
#' @examples
simulate_PP <- function(rates, rsamplers, params){
n_groups <- length(rates)
coords_list <- list()
for (group in 1:n_groups){
rate <- rates[group]
rsample <- rsamplers[[group]]
param_list <- params[[group]]
n_obs <- rpois(1, rate) # Sample total number of observations
param_list$n <- n_obs
coords <- do.call(rsample, param_list) # Sample coordinates of observations
coords <- cbind(coords, rep(group, n_obs))
coords_list[[group]] <- coords
}
# Combine coordinate data
data <- as.data.frame(do.call(rbind, coords_list))
names(data) <- c("x", "y", "group")
return(as.data.frame(data))
}
data <- simulate_PP(rates, rsamplers, params)
data
nrow(data)
# Load in helper functions
source(here::here("helper-functions", "simulate_PP.R"))
source(here::here("helper-functions", "runif2D.R"))
source(here::here("helper-functions", "rline.R"))
source(here::here("helper-functions", "roffset.R"))
outdir <- here::here("data", "simulated")
set.seed(5417326)
rates <- rep(150, 4)
rsamplers <- list(runif2D, rline, rline, roffset)
rsamplers
# Load in helper functions
source(here::here("helper-functions", "simulate_PP.R"))
# Load in helper functions
source(here::here("helper-functions", "simulate_PP.R"))
source(here::here("helper-functions", "runif2D.R"))
source(here::here("helper-functions", "rline.R"))
source(here::here("helper-functions", "roffset.R"))
outdir <- here::here("data", "simulated")
set.seed(5417326)
n_datasets <- 50 # number of generated data sets
# Fix parameters for generated data sets
rates <- rep(150, 4)
rsamplers <- list(runif2D, rline, rline, roffset)
params <- list()
params[[1]] <- list()
params[[2]] <- list(sd = 0.1)
params[[3]] <- list(sd = 0.03)
params[[4]] <- list(sd = 0.1, offset = 0.3)
# Generate data
for (dataset_no in 1:n_datasets){
filename <- paste0("/sim_", as.character(dataset_no), ".csv")
data <- simulate_PP(rates, rsamplers, params)
write.csv(data, paste0(outdir, filename), row.names = FALSE)
}
# Generate data
for (dataset_no in 1:n_datasets){
filename <- paste0("/sim_", as.character(dataset_no), ".csv")
data <- simulate_PP(rates, rsamplers, params)
write.csv(data, paste0(outdir, filename), row.names = FALSE)
}
